<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>roimarker.marker API documentation</title>
<meta name="description" content="roimarker - A general purpose marker/annotation tool.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>roimarker.marker</code></h1>
</header>
<section id="section-intro">
<p>roimarker - A general purpose marker/annotation tool.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="roimarker.marker.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Running marker as a tool directly from terminal / command line.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="roimarker.marker.Marker"><code class="flex name class">
<span>class <span class="ident">Marker</span></span>
<span>(</span><span>fig, ax, image_fns, markings_savefn, crops=None, clipping=True, old_markings=None, callback_on_exit=None, reselect_fns=None, relative_fns_from=None, drop_imagefn=False, selection_type='box')</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a matplotlib figure for annotating images.</p>
<p>See also documentation at the <strong>init</strong> method.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>visible_rectangles</code></strong> :&ensp;<code>list</code></dt>
<dd>Contains the matplotlib Rectangle-patches for the selected ROIs
in the current image.</dd>
</dl>
<p>Marking interests of region (ROIs) on images.</p>
<p>After selecting the ROIs, a separate json file (markings_savefn) is created, which
contains dictionary {image1_fn: [[ROI1, ROI2, &hellip;]], &hellip;}
where ROI = [x,y,w,h]
(or [x1,y1,x2,y2] when selection_type='arrow')</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>fig</code></strong>, <strong><code>ax</code></strong> :&ensp;<code>objects</code></dt>
<dd>What matplotlib plt.subplots() gives you</dd>
<dt><strong><code>image_fns</code></strong> :&ensp;<code>list</code> of <code>strings</code></dt>
<dd>A list of image file names that are to be annotated</dd>
<dt><strong><code>markings_savefn</code></strong> :&ensp;<code>string</code></dt>
<dd>Filename where the annotations are saved. If None do not save</dd>
<dt><strong><code>crops</code></strong> :&ensp;<code>sequence</code> of <code>4 ints</code></dt>
<dd>List where an item is crop[ [x,y,w,h] for each image.
It is save to (accidentally) crop over the image coordinates.</dd>
<dt><strong><code>old_markings</code></strong> :&ensp;<code>string</code> or <code>dict</code> or <code>True</code></dt>
<dd>Either filename to old markings (a string),
loaded old markings (dict {fn: [x,y,w,h]}, &hellip;),
or True to load from markings_savefn.</dd>
<dt><strong><code>callback_on_exit</code></strong> :&ensp;<code>callable</code></dt>
<dd>This gets called on successfull exit</dd>
<dt><strong><code>reslect_fns</code></strong> :&ensp;<code>list</code> of <code>strings</code></dt>
<dd>List of image filenames should be remarked even if previous markings
exist.</dd>
<dt><strong><code>relative_fns_from</code></strong> :&ensp;<code>string</code></dt>
<dd>If a valid path, the saved markings contain relative filenames starting from
this directory instead of the full, absolute filenames.</dd>
<dt><strong><code>drop_imagefn</code></strong> :&ensp;<code>bool</code></dt>
<dd>Omits the image file name from the final markings dictionary.
May be usefull if marking made for the image in the folder
is to be used for all other images in the folder as well.</dd>
<dt><strong><code>selection_type</code></strong> :&ensp;<code>string</code></dt>
<dd>'box' or 'arrow'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Marker:
    &#39;&#39;&#39;Opens a matplotlib figure for annotating images.

    See also documentation at the __init__ method.

    Attributes
    ----------
    visible_rectangles : list
        Contains the matplotlib Rectangle-patches for the selected ROIs
        in the current image.
    &#39;&#39;&#39;
    
    def __init__(self, fig, ax, image_fns, markings_savefn, crops=None, clipping=True, old_markings=None,
            callback_on_exit=None, reselect_fns=None,
            relative_fns_from=None, drop_imagefn = False,
            selection_type=&#39;box&#39;):
        &#39;&#39;&#39;
        Marking interests of region (ROIs) on images.

        After selecting the ROIs, a separate json file (markings_savefn) is created, which
        contains dictionary {image1_fn: [[ROI1, ROI2, ...]], ...}
            where ROI = [x,y,w,h]    (or [x1,y1,x2,y2] when selection_type=&#39;arrow&#39;)
        
        Arguments
        ---------
        fig, ax : objects
            What matplotlib plt.subplots() gives you
        image_fns : list of strings
            A list of image file names that are to be annotated
        markings_savefn : string
            Filename where the annotations are saved. If None do not save
        crops : sequence of 4 ints
            List where an item is crop[ [x,y,w,h] for each image.
            It is save to (accidentally) crop over the image coordinates.
        old_markings : string or dict or True
            Either filename to old markings (a string),
            loaded old markings (dict {fn: [x,y,w,h]}, ...),
            or True to load from markings_savefn.
        callback_on_exit : callable
            This gets called on successfull exit
        reslect_fns: list of strings
            List of image filenames should be remarked even if previous markings
            exist.
        relative_fns_from : string
            If a valid path, the saved markings contain relative filenames starting from
            this directory instead of the full, absolute filenames.
        drop_imagefn : bool
            Omits the image file name from the final markings dictionary.
            May be usefull if marking made for the image in the folder
            is to be used for all other images in the folder as well.
        selection_type : string
            &#39;box&#39; or &#39;arrow&#39;
        &#39;&#39;&#39;
        
        self.fig = fig
        self.ax = ax
            
        self.fns = image_fns
        
        self.crops = crops

        self.current = None
        self.current_i = -1

        self.markings = {}
        self.N_previous = 0
        self.reselect_fns = reselect_fns
        
        if relative_fns_from is not None and not os.path.isdir(relative_fns_from):
            raise ValueError(&#34;relative_fns_from if set, has to be a proper a proper directory&#34;)

        self.relative_fns_from = relative_fns_from
        self.drop_imagefn = drop_imagefn

        self.clipping = clipping
        self.image_maxval = 1
        self.image_minval = 0 
        
        self.image = None
        self.previous_image_shape = None

        self.cid = self.fig.canvas.mpl_connect(&#39;key_press_event&#39;, self.__button_pressed)
        
        if selection_type == &#39;box&#39;:
            self.rectangle = RectangleSelector(ax, self._on_select_rectangle, useblit=True)
        elif selection_type == &#39;arrow&#39;:
            self.rectangle = ArrowSelector(ax, self._on_select_arrow)
        else:
            raise ValueError(&#39;Selection type for Marker has to be &#34;box or &#34;arrow&#34;, not {}&#39;.format(selection_type))
        
        self.markings_savefn = markings_savefn
        
        if old_markings:
            if old_markings is True:
                self.load_markings(self.markings_savefn)
            elif type(old_markings) == type(&#39;string&#39;):
                if os.path.isfile(old_markings):
                    self.load_markings(old_markings)
                else:
                    print(&#34;Warning! Couldn&#39;t import old_markings in Marker (marker.py)&#34;)
            elif type(old_markings) == type({}):
                print(&#39;Wrong oges&#39;)
                self.markings = old_marking
            elif type(old_markings) == type([]):
                raise NotImplementedError(&#39;Giving many old markings not yet implemented&#39;)
            else:
                raise TypeError(&#39;old_markings in incorrect type for Marker at marker.py&#39;)
            

            # If relative_fns_from is set, it is expected that for any previous
            # ROI selections, relative_fns_from was also set even if the directory may
            # have been different.
            # If this is not the case, previous data is not use but in the case of
            # platform (OS) jump problems arise for sure. FIXME?
            self.markings = {os.path.join(relative_fns_from, fn): rois for fn, rois in self.markings.items()
                    if not os.path.isabs(fn)}

        self.exit = False
        self.callback_on_exit = callback_on_exit
        self.fig.canvas.mpl_connect(&#39;close_event&#39;, lambda x: self.close())

        self.visible_rectangles = []


    def _get_relative_markings(self):
        &#39;&#39;&#39;
        Returns self.markings but with relative filesnames with rescpect to
        self.relative_fns_from if set. If not set, just returns self.markings
        &#39;&#39;&#39;

        if self.relative_fns_from:
            fns = {os.path.relpath(fn, start=self.relative_fns_from): rois for fn, rois in self.markings.items()}
        else:
            fns =  self.markings
        
        if self.drop_imagefn:
            fns = {os.path.dirname(fn): rois for fn, rois in fns.items()}
        
        return fns


    def run(self):
        &#39;&#39;&#39;
        Run the marking process where user selects ROIs for each given image.

        Returns self.markings that is a dictionary with image filenames as keys
        and ROIs as items.
        &#39;&#39;&#39;
        self.next_image()
        
        self.ax.text(0, 1.02, &#39;n: Next image\nx &amp; z: Change brightness capping\nw: Save\nAutosave after the last image&#39;, transform=self.ax.transAxes,
                verticalalignment=&#39;bottom&#39;)
        
        plt.show(block=False)
        
        while self.exit == False:
            try:
                self.fig.canvas.start_event_loop(0.1)
            except:
                break
    
        plt.close(self.fig)   
        
        if self.current_i == len(self.fns):
            self.save_markings()
            tkinter.messagebox.showinfo(&#39;All images processed&#39;,
                    &#39;Markings saved at\n{}&#39;.format(self.markings_savefn))
        
        if self.callback_on_exit:
            self.callback_on_exit()
        
        return self._get_relative_markings()


    def __button_pressed(self, event):
        &#39;&#39;&#39;A callback funtion for matplotlib&#39;s event manager to handle buttons.
        &#39;&#39;&#39;
        key = event.key

        # Navigating between the images
        if key == &#39;n&#39;:
            self.next_image()
        elif key == &#39;w&#39;:
            self.save_markings()

        elif key == &#39;z&#39;:
            self.image_maxval -= 0.3
            self.update_image()
        elif key == &#39;x&#39;:
            self.image_maxval += 0.3
            self.update_image()
        elif key == &#39;c&#39;:
            self.image_minval -= 0.2
            self.update_image()
        elif key == &#39;v&#39;:
            self.image_minval += 0.2
            self.update_image()
        
        elif event.key == &#39;ctrl+z&#39;:
            if self.markings[self.current]:
                self.markings[self.current].pop(-1)

            if self.visible_rectangles:
                self.visible_rectangles.pop(-1).remove()
                plt.draw()


    def _on_select_rectangle(self, eclick, erelease):
        
        # Get selection box coordinates and set the box inactive
        x1, y1 = eclick.xdata, eclick.ydata
        x2, y2 = erelease.xdata, erelease.ydata
        
        x = int(min((x1, x2)))
        y = int(min((y1, y2)))
        width = int(abs(x2-x1))
        height = int(abs(y2-y1))

        try:
            self.markings[self.current]
        except KeyError:
            self.markings[self.current] = []
        
        self.markings[self.current].append([x, y, width, height])
        
        # Add a static rectangle to show the made selection
        rectangle = Rectangle(
                (x,y), width, height,
                alpha=0.2)
        self.ax.add_patch(rectangle)
        self.visible_rectangles.append(rectangle)
        plt.draw()


    def _on_select_arrow(self, eclick, erelease):
        
        try:
            self.markings[self.current]
        except KeyError:
            self.markings[self.current] = []
        
        x1, y1 = eclick.xdata, eclick.ydata
        x2, y2 = erelease.xdata, erelease.ydata       
        
        self.markings[self.current].append([x1, y1, x2, y2])

       

    def next_image(self):
        
        self.current_i += 1

        if self.current_i &gt;= len(self.fns):
            self.exit = True    
            return 0

        for fn in self.fns[self.current_i:]:
            print(fn)
            if not fn in self.markings.keys() and self.reselect_fns is None:
                self.current = fn
                break

            if os.path.basename(os.path.dirname(fn)) in self.reselect_fns:
                self.current = fn
                break          
            self.current_i += 1
        
        if self.current_i &gt;= len(self.fns):
            self.current_i == len(self.fns)
            self.exit = True
            return 0
        
        # Remove rectangle visible selections
        for patch in self.visible_rectangles:
            patch.remove()
        self.visible_rectangles = []

        # Set marking to empty
        self.markings[self.current] = []
       
        self.fig.suptitle(self.current, fontsize=8)

        print(&#39;Annotating image {}/{}&#39;.format(self.current_i+1+self.N_previous, len(self.fns)+self.N_previous))
        print(self.current)
        if self.image is not None:
            self.previous_image_shape = self.image.shape
        
        try:
            self.image = tifffile.TiffFile(self.current).asarray(key=0).astype(np.float32)
        except ValueError as e:
            print(&#39;Old markings&#39;)
            raise ValueError(&#39;\n{}Cannot read file {}&#39;.format(self.current))
        
        # If stack, take the first image
        if len(self.image.shape) == 3:
            self.image = self.image[0,:,:]
        
        self.image -= np.min(self.image)
        self.image /= np.max(self.image)
        self.update_image()


    def update_image(self):
        
        image = self.image

        if self.clipping:
            capvals = (np.mean(image) * self.image_minval, np.mean(image) *self.image_maxval)
            image = np.clip(image, *capvals) - capvals[0]
            image /= np.max(image)

        if image.shape == self.previous_image_shape:
            self.ax_imshow.set_data(image)
        else:
            self.ax_imshow = self.ax.imshow(image, cmap=&#39;gist_gray&#39;, interpolation=&#39;nearest&#39;, vmin=0, vmax=1) #extent=[0, image.shape[0], 0, image.shape[1]])
        
        if self.crops:
            c = self.crops[self.current_i]
            self.ax.set_xlim(c[0], c[0]+c[2])
            self.ax.set_ylim(c[1]+c[3], c[1])

        # If previous image shape not set at this point (opening the first image),
        # then use current shape as the previous also (othewise a bug that on the
        # first image setting brightess is slow and slows down the program
        # progressively)
        if self.previous_image_shape is None:
            self.previous_image_shape = self.image.shape

        plt.draw()
       
    
    def set_markings_savefn(self, fn):
        self.markings_savefn = fn


    def load_markings(self, fn):
        
        with open(fn, &#39;r&#39;) as fp:
            markings = json.load(fp)
        self.markings = markings


    def save_markings(self):
        &#39;&#39;&#39;
        Saves the markings as a json file
        &#39;&#39;&#39;
        if self.markings_savefn is None:
            return None

        with open(self.markings_savefn, &#39;w&#39;) as fp:
            json.dump(self._get_relative_markings(), fp)


    def get_markings(self):
        return self._get_relative_markings()


    def get_current_marking(self):
        return [self.current, self.markings[self.current][-1]]

    
    def close(self):
        self.exit = True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="roimarker.marker.Marker.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="roimarker.marker.Marker.get_current_marking"><code class="name flex">
<span>def <span class="ident">get_current_marking</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="roimarker.marker.Marker.get_markings"><code class="name flex">
<span>def <span class="ident">get_markings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="roimarker.marker.Marker.load_markings"><code class="name flex">
<span>def <span class="ident">load_markings</span></span>(<span>self, fn)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="roimarker.marker.Marker.next_image"><code class="name flex">
<span>def <span class="ident">next_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="roimarker.marker.Marker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the marking process where user selects ROIs for each given image.</p>
<p>Returns self.markings that is a dictionary with image filenames as keys
and ROIs as items.</p></div>
</dd>
<dt id="roimarker.marker.Marker.save_markings"><code class="name flex">
<span>def <span class="ident">save_markings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the markings as a json file</p></div>
</dd>
<dt id="roimarker.marker.Marker.set_markings_savefn"><code class="name flex">
<span>def <span class="ident">set_markings_savefn</span></span>(<span>self, fn)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="roimarker.marker.Marker.update_image"><code class="name flex">
<span>def <span class="ident">update_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href='../index.html'><- Back to All Docs</a><br>
<a href="javascript:history.back()"><- Back one page</a>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="roimarker" href="index.html">roimarker</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="roimarker.marker.main" href="#roimarker.marker.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="roimarker.marker.Marker" href="#roimarker.marker.Marker">Marker</a></code></h4>
<ul class="two-column">
<li><code><a title="roimarker.marker.Marker.close" href="#roimarker.marker.Marker.close">close</a></code></li>
<li><code><a title="roimarker.marker.Marker.get_current_marking" href="#roimarker.marker.Marker.get_current_marking">get_current_marking</a></code></li>
<li><code><a title="roimarker.marker.Marker.get_markings" href="#roimarker.marker.Marker.get_markings">get_markings</a></code></li>
<li><code><a title="roimarker.marker.Marker.load_markings" href="#roimarker.marker.Marker.load_markings">load_markings</a></code></li>
<li><code><a title="roimarker.marker.Marker.next_image" href="#roimarker.marker.Marker.next_image">next_image</a></code></li>
<li><code><a title="roimarker.marker.Marker.run" href="#roimarker.marker.Marker.run">run</a></code></li>
<li><code><a title="roimarker.marker.Marker.save_markings" href="#roimarker.marker.Marker.save_markings">save_markings</a></code></li>
<li><code><a title="roimarker.marker.Marker.set_markings_savefn" href="#roimarker.marker.Marker.set_markings_savefn">set_markings_savefn</a></code></li>
<li><code><a title="roimarker.marker.Marker.update_image" href="#roimarker.marker.Marker.update_image">update_image</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
