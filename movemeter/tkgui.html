<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>movemeter.tkgui API documentation</title>
<meta name="description" content="A tkinter/tk GUI for Movemeter the motion analysis tool â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>movemeter.tkgui</code></h1>
</header>
<section id="section-intro">
<p>A tkinter/tk GUI for Movemeter the motion analysis tool.</p>
<h2 id="features-in-short">Features In Short</h2>
<ul>
<li>Load, view and exclude images</li>
<li>Draw variously shaped ROIs that are made from small,
rectangular (square) cross-correlation windows,
and allow grouping these ROIs</li>
<li>Perform motion analysis and save results</li>
<li>View and save motion analysis heatmaps</li>
</ul>
<p>This file contains most of the GUI elements extra logic (such as saving results)
that are not present in the movemeter.py file.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="movemeter.tkgui.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize tkinter and start the Movemeter GUI.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="movemeter.tkgui.ColormapSelector"><code class="flex name class">
<span>class <span class="ident">ColormapSelector</span></span>
<span>(</span><span>tk_parent, callback, startmap=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Widget to preview and select a matplotlib colormap.</p>
<p>tk_parent : object
Tkinter parent widget
callback : callable
When selected, the colormap passed to this callback function
startmap : string
Name of the colormap to start with.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColormapSelector(tk.Frame):
    &#39;&#39;&#39;
    Widget to preview and select a matplotlib colormap.
    &#39;&#39;&#39;
    def __init__(self, tk_parent, callback, startmap=None):
        &#39;&#39;&#39;
        tk_parent : object
            Tkinter parent widget
        callback : callable
            When selected, the colormap passed to this callback function
        startmap : string
            Name of the colormap to start with.
        &#39;&#39;&#39;
        tk.Frame.__init__(self, tk_parent)
        
        self._callback = callback

        # Dict of all availbale colormap objects
        self.colormaps = {name: getattr(matplotlib.cm, name) for name in dir(matplotlib.cm) if isinstance(
            getattr(matplotlib.cm, name), matplotlib.colors.Colormap)}

       
        self.listbox = Listbox(self, list(self.colormaps.keys()), callback=self.on_selection)
        self.listbox.grid(row=1, column=1, sticky=&#39;NSWE&#39;)

        self.plotter = CanvasPlotter(self, text=&#39;Preview&#39;, figsize=(0.5,5))
        self.plotter.grid(row=1, column=2, sticky=&#39;NSWE&#39;)
        
        data = np.linspace(0,10)[:, np.newaxis]
        self.plotter.imshow(data)
        if startmap:
            self.on_selection(startmap)

        self.select_button = tk.Button(self, text=&#39;Ok&#39;, command=self.on_ok)
        self.select_button.grid(row=2, column=1, columnspan=2, sticky=&#39;NSWE&#39;)

        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(1, weight=10)
        self.grid_columnconfigure(1, weight=1)


    def on_selection(self, name):
        self._current = name
        self.plotter.imshow_obj.cmap = self.colormaps[name]
        self.plotter.update()


    def on_ok(self):
        self._callback(self.colormaps[self._current])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="movemeter.tkgui.ColormapSelector.on_ok"><code class="name flex">
<span>def <span class="ident">on_ok</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="movemeter.tkgui.ColormapSelector.on_selection"><code class="name flex">
<span>def <span class="ident">on_selection</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="movemeter.tkgui.MovemeterSettings"><code class="flex name class">
<span>class <span class="ident">MovemeterSettings</span></span>
<span>(</span><span>tk_parent)</span>
</code></dt>
<dd>
<div class="desc"><p>Movemeter settings widget, semi-automatically inspected from
the Movemeter.<strong>init</strong> method.</p>
<p>Use get_current method to retrive the setting dictionary.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>tickboxes</code></strong> :&ensp;<code>object</code></dt>
<dd>tk_steroids TickboxFrame containing False/True options.</dd>
<dt><strong><code>maxmovement_slider</code></strong>, <strong><code>blur_slider</code></strong>, <strong><code>cores_slider</code></strong>, <strong><code>upscale_slider</code></strong> :&ensp;<code>object</code></dt>
<dd>tkinter Slider widgets</dd>
</dl>
<p>tk_parent
Tkinter parent widget</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MovemeterSettings(tk.Frame):
    &#39;&#39;&#39;
    Movemeter settings widget, semi-automatically inspected from
    the Movemeter.__init__ method.

    Use get_current method to retrive the setting dictionary.

    Attributes
    ----------
    tickboxes : object
        tk_steroids TickboxFrame containing False/True options.
    maxmovement_slider, blur_slider, cores_slider, upscale_slider: object
        tkinter Slider widgets
    &#39;&#39;&#39;
    def __init__(self, tk_parent):
        &#39;&#39;&#39;
        tk_parent       Tkinter parent widget
        &#39;&#39;&#39;
        tk.Frame.__init__(self, tk_parent)
        self.columnconfigure(2, weight=1)

        # Movemeter True/False options; Automatically inspect from Movemeter.__init__
        moveinsp = inspect.getfullargspec(Movemeter.__init__)

        moveargs = []
        movedefaults = []
        for i in range(1, len(moveinsp.args)):
            arg = moveinsp.args[i]
            default = moveinsp.defaults[i-1]
            if isinstance(default, bool) and arg not in [&#39;multiprocess&#39;]:
                moveargs.append(arg)
                movedefaults.append(default)
        

        # GUI elements next
        # True/false - motion analysis options
        self.tickboxes = TickboxFrame(self, moveargs, defaults=movedefaults)
        self.tickboxes.grid(row=2, column=1, columnspan=2)
        
        # Preprocessing options
        tk.Label(self, text=&#39;Gaussian blur&#39;).grid(row=3, column=1)
        self.blur_slider = tk.Scale(self, from_=0, to=32, orient=tk.HORIZONTAL)
        self.blur_slider.set(0)
        self.blur_slider.grid(row=3, column=2, sticky=&#39;NSWE&#39;)

        # Numerical value - motion analysis options
        tk.Label(self, text=&#39;Maximum movement&#39;).grid(row=4, column=1)
        self.maxmovement_slider = tk.Scale(self, from_=1, to=100,
                orient=tk.HORIZONTAL)
        self.maxmovement_slider.set(10)
        self.maxmovement_slider.grid(row=4, column=2, sticky=&#39;NSWE&#39;)

        tk.Label(self, text=&#39;Upscale&#39;).grid(row=5, column=1)
        self.upscale_slider = tk.Scale(self, from_=0.1, to=10,
                orient=tk.HORIZONTAL, resolution=0.1)
        self.upscale_slider.set(5)
        self.upscale_slider.grid(row=5, column=2, sticky=&#39;NSWE&#39;)

        tk.Label(self, text=&#39;Parallel processes&#39;).grid(row=6, column=1)
        self.cores_slider = tk.Scale(self, from_=1, to=os.cpu_count(),
                orient=tk.HORIZONTAL)
        self.cores_slider.set(max(1, int(os.cpu_count()/2)))
        self.cores_slider.grid(row=6, column=2, sticky=&#39;NSWE&#39;)


    def get_current(self):
        &#39;&#39;&#39;
        Returns a dictionary of the current settings that can be directly
        passed to the Movemeter.__init__ method.
        &#39;&#39;&#39;
        settings = {&#39;upscale&#39;: float(self.upscale_slider.get()),
                &#39;max_movement&#39;: int(self.maxmovement_slider.get()),
                &#39;multiprocess&#39;: int(self.cores_slider.get())}

        if settings[&#39;multiprocess&#39;] == 1:
            settings[&#39;multiprocess&#39;] = False

        return {**self.tickboxes.states, **settings}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="movemeter.tkgui.MovemeterSettings.get_current"><code class="name flex">
<span>def <span class="ident">get_current</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary of the current settings that can be directly
passed to the Movemeter.<strong>init</strong> method.</p></div>
</dd>
</dl>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui"><code class="flex name class">
<span>class <span class="ident">MovemeterTkGui</span></span>
<span>(</span><span>tk_parent)</span>
</code></dt>
<dd>
<div class="desc"><p>Main widget for the Movemeter tkinter GUI.</p>
<h2 id="attributes">Attributes</h2>
<p>self.parent : object
tkinter parent widget</p>
<dl>
<dt><strong><code>folders</code></strong> :&ensp;<code>list</code></dt>
<dd>List of opened directories</dd>
<dt><strong><code>folders_listbox</code></strong> :&ensp;<code>object</code></dt>
<dd>tk_steroids Listbox of opened directories</dd>
<dt><strong><code>current_folder</code></strong> :&ensp;<code>string</code></dt>
<dd>The currently selected folder from self.folder</dd>
<dt><strong><code>image_fns</code></strong> :&ensp;<code>string</code></dt>
<dd>List of image filenames in th current folder.</dd>
<dt><strong><code>images</code></strong> :&ensp;<code>list</code> of <code>Nones</code> or <code>list</code> of <code>ndarray</code></dt>
<dd>Initially list of Nones, as long as many images there are.
Incrimentally, becomes a list of images (numpy array).</dd>
<dt><strong><code>exclude_images</code></strong> :&ensp;<code>list</code></dt>
<dd>List of image filenames or indices to exclude from the analysis.</dd>
<dt><strong><code>fs</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Sampling rate of the images, in Hz (1/s). Global for all data.</dd>
<dt><strong><code>filename_extensions</code></strong> :&ensp;<code>tuple</code> of <code>strings</code></dt>
<dd>Accepted filename extensions for images (or videos).</dd>
</dl>
<p>self.N_frames : dict
For video files of image stacks, contains the amount of frames
per each file and the filenames are the keys.</p>
<dl>
<dt><strong><code>selections</code></strong> :&ensp;<code>list</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Construct a frame widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, class,
colormap, container, cursor, height, highlightbackground,
highlightcolor, highlightthickness, relief, takefocus, visual, width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MovemeterTkGui(tk.Frame):
    &#39;&#39;&#39;
    Main widget for the Movemeter tkinter GUI.
    
    ATTRIBUTES
    -----------
    self.parent : object
        tkinter parent widget

    folders : list
        List of opened directories
    folders_listbox : object
        tk_steroids Listbox of opened directories
    current_folder : string
        The currently selected folder from self.folder
    image_fns : string
        List of image filenames in th current folder.
    images : list of Nones or list of ndarray
        Initially list of Nones, as long as many images there are.
        Incrimentally, becomes a list of images (numpy array).
    exclude_images : list
        List of image filenames or indices to exclude from the analysis.
    fs : int or float
        Sampling rate of the images, in Hz (1/s). Global for all data.
    
    filename_extensions : tuple of strings
        Accepted filename extensions for images (or videos).
    self.N_frames : dict
        For video files of image stacks, contains the amount of frames
        per each file and the filenames are the keys.
    
    selections : list
    
    &#39;&#39;&#39;

    def __init__(self, tk_parent):
        tk.Frame.__init__(self, tk_parent)
        self.parent = tk_parent

        # Data and images
        self.folders = []
        self.current_folder = None
        self.image_fns = []
        self.images = None
        self.exclude_images = []
        self.fs = 100
        
        self.filename_extensions = (&#39;.tiff&#39;, &#39;.tif&#39;, &#39;.mp4&#39;)
        self.N_frames = {}
       
        # Selections and ROIs
        self.selections = []
        self.roi_groups = []
        self.current_roi_group = 0
        self.roi_patches = []
        
        self.colors = matplotlib.cm.ScalarMappable(cmap=matplotlib.cm.tab10)
        self.colors.set_clim(0,10)

        # Motion analysis
        self.movemeter = Movemeter()
        self.results = []
        self.heatmap_images = []
        self.batch_name = &#39;batch_name&#39;

        self.show_controls = False

        # Other
        self.use_mask_image = False
        self.mask_image = None
       

        # Top menu
        # --------------------------------
        self.menu = tk.Menu(self)
        
        filemenu = tk.Menu(self)
        filemenu.add_command(label=&#39;Add directory...&#39;, command=self.open_directory)
        filemenu.add_separator()
        filemenu.add_command(label=&#39;Load ROIs&#39;,
                command=lambda: self.apply_movzip(rois=True))
        filemenu.add_command(label=&#39;Save ROIs&#39;,
                command=lambda: self._save_movzip(only=[&#39;rois&#39;, &#39;selections&#39;]))
        
        filemenu.add_separator()
        filemenu.add_command(label=&#39;Save ROI view&#39;,
                command=self.save_roiview)
        
        filemenu.add_command(label=&#39;Save ROIs only view&#39;,
                command=lambda: self.save_roiview(only_rois=True))
        filemenu.add_separator()
        filemenu.add_command(label=&#39;Quit&#39;, command=self.parent.destroy) 
        
        self.menu.add_cascade(label=&#39;File&#39;, menu=filemenu)
        

        editmenu = tk.Menu(self)
        editmenu.add_command(label=&#39;Undo (latest ROI)&#39;, command=self.undo)
        editmenu.add_separator()
        editmenu.add_command(label=&#39;Global settings&#39;, command=self.open_settings)
        self.menu.add_cascade(label=&#39;Edit&#39;, menu=editmenu)

        viewmenu = tk.Menu(self)
        viewmenu.add_command(label=&#39;Show image controls&#39;, command=self.toggle_controls)
        self.menu.add_cascade(label=&#39;View&#39;, menu=viewmenu)
        
        batchmenu = tk.Menu(self)
        batchmenu.add_command(label=&#39;Batch measure &amp; save all&#39;, command=self.batch_process)
        batchmenu.add_separator()
        batchmenu.add_command(label=&#39;Reprocess rectangular selection (with current block settings)&#39;,
                command=self.recalculate_old)
        batchmenu.add_command(label=&#39;Replot heatmap&#39;, command=self.replot_heatmap)
 
        self.menu.add_cascade(label=&#39;Batch&#39;, menu=batchmenu)

        toolmenu = tk.Menu(self)
        toolmenu.add_command(label=&#39;Heatmap tool&#39;, command=lambda: open_httool(self))
        self.menu.add_cascade(label=&#39;Tools&#39;, menu=toolmenu)
        

        self.parent.config(menu=self.menu)


        # Input folders

        self.folview = tk.LabelFrame(self, text=&#39;Input folders&#39;)
        self.folview.rowconfigure(2, weight=1)
        self.folview.columnconfigure(1, weight=1)
        self.folview.grid(row=0, column=1, sticky=&#39;NSWE&#39;)

        self.folders_listbox = Listbox(self.folview, [&#39;No folders selected&#39;], self.folder_selected)
        self.folders_listbox.listbox.config(height=10)
        self.folders_listbox.grid(row=2, column=1, columnspan=2, sticky=&#39;NSWE&#39;)

        self.imview_buttons = ButtonsFrame(self.folview,
                [&#39;Add...&#39;, &#39;Remove&#39;, &#39;FS&#39;],
                [self.open_directory, self.remove_directory, self.set_fs])
        self.imview_buttons.grid(row=0, column=1) 
        self.fs_button = self.imview_buttons.buttons[2]
        self.set_fs(fs=self.fs)

        # Operations view
        # -------------------------
        self.opview = tk.LabelFrame(self, text=&#39;Command center&#39;)
        self.opview.grid(row=0, column=2, sticky=&#39;NSWE&#39;)
        
        self.tabs = Tabs(self.opview,
                [&#39;Style&#39;, &#39;ROI creation&#39;, &#39;Motion analysis&#39;, &#39;Brightness analysis&#39;],
                draw_frame = True)
        self.tabs.grid(row=0, column=1, columnspan=2, sticky=&#39;NSWE&#39;)
        self.tabs.set_page(1) 
       
        self.styleview = self.tabs.tabs[0]
        self.styleview.columnconfigure(2, weight=1)
        
        self.colormap_label = tk.Label(self.styleview, text=&#39;Colormap&#39;)
        self.colormap_label.grid(row=1, column=1)
        self.colormap_selection = tk.Button(self.styleview, text=self.colors.get_cmap().name,
                command=self.open_colormap_selection)
        self.colormap_selection.grid(row=1, column=2)
        
        tk.Label(self.styleview, text=&#39;Line width&#39;).grid(row=2, column=1)
        self.patch_lw_slider = tk.Scale(self.styleview, from_=0, to_=10,
                orient=tk.HORIZONTAL)
        self.patch_lw_slider.set(1)
        self.patch_lw_slider.grid(row=2, column=2, sticky=&#39;NSWE&#39;)
        
        tk.Label(self.styleview, text=&#39;Fill strength&#39;).grid(row=3, column=1)
        self.patch_fill_slider = tk.Scale(self.styleview, from_=0, to=100,
                orient=tk.HORIZONTAL)
        self.patch_fill_slider.grid(row=3, column=2, sticky=&#39;NSWE&#39;)
        self.patch_fill_slider.set(40)



        self.roiview = self.tabs.tabs[1]
        self.roiview.columnconfigure(2, weight=1)

        self.roi_drawtypes = {&#39;box&#39;: &#39;box&#39;,
                &#39;ellipse&#39;: &#39;ellipse&#39;,
                &#39;line&#39;: &#39;line&#39;,
                &#39;polygon&#39;: &#39;polygon&#39;,
                &#39;arc_from_points&#39;: &#39;polygon&#39;,
                &#39;concentric_arcs_from_points&#39;: &#39;polygon&#39;,
                &#39;radial_lines_from_points&#39;: &#39;polygon&#39;}

        tk.Label(self.roiview, text=&#39;Selection mode&#39;).grid(row=1, column=1)
        self.selmode_frame = tk.Frame(self.roiview)
        self.selmode_frame.grid(row=1, column=2)
        
        self.roitype_selection = DropdownList(self.selmode_frame,
                [&#39;box&#39;, &#39;ellipse&#39;, &#39;line&#39;, &#39;polygon&#39;, &#39;arc_from_points&#39;,
                    &#39;concentric_arcs_from_points&#39;,
                    &#39;radial_lines_from_points&#39;], 
                [&#39;Box&#39;, &#39;Ellipse&#39;, &#39;Line&#39;, &#39;Polygon&#39;, &#39;Arc from points&#39;,
                    &#39;Concentric Arcs (++RG)&#39;,
                    &#39;Radial lines (++RG)&#39;],
                single_select=True, callback=self.update_roitype_selection)
        self.roitype_selection.grid(row=1, column=2)

        self.drawmode_selection = TickboxFrame(self.selmode_frame,
                [&#39;add&#39;, &#39;remove&#39;], [&#39;Add&#39;, &#39;Remove&#39;],
                single_select=True
                )
        self.drawmode_selection.grid(row=1, column=1)


        tk.Label(self.roiview, text=&#39;Block size&#39;).grid(row=3, column=1)
        self.blocksize_slider = tk.Scale(self.roiview, from_=16, to=128,
                orient=tk.HORIZONTAL)
        self.blocksize_slider.set(32)
        self.blocksize_slider.grid(row=3, column=2, sticky=&#39;NSWE&#39;)

        tk.Label(self.roiview, text=&#39;Block distance&#39;).grid(row=4, column=1)
        self.overlap_slider = tk.Scale(self.roiview, from_=1, to=128,
                orient=tk.HORIZONTAL, resolution=1)
        self.overlap_slider.set(32)
        self.overlap_slider.grid(row=4, column=2, sticky=&#39;NSWE&#39;)
        
        self.distance_label = tk.Label(self.roiview, text=&#39;Line-block distance&#39;)
        self.distance_label.grid(row=5, column=1)
        self.distance_slider = tk.Scale(self.roiview, from_=1, to=128,
                orient=tk.HORIZONTAL, resolution=1)
        self.distance_slider.set(32)
        self.distance_slider.grid(row=5, column=2, sticky=&#39;NSWE&#39;)

        
        self.nroi_label = tk.Label(self.roiview, text=&#39;Count&#39;)
        self.nroi_label.grid(row=6, column=1)
        self.nroi_label.grid_remove()
        self.nroi_slider = tk.Scale(self.roiview, from_=1, to=128,
                orient=tk.HORIZONTAL, resolution=1)
        self.nroi_slider.grid(row=6, column=2, sticky=&#39;NSWE&#39;)
        self.nroi_slider.grid_remove()

        self.radial_len_label = tk.Label(self.roiview, text=&#39;Radial line length&#39;)
        self.radial_len_label.grid(row=7, column=1)
        self.radial_len_label.grid_remove()
        self.radial_len_slider = tk.Scale(self.roiview, from_=1, to=1024,
                orient=tk.HORIZONTAL, resolution=1)
        self.radial_len_slider.grid(row=7, column=2, sticky=&#39;NSWE&#39;)
        self.radial_len_slider.grid_remove()



        self.roi_buttons = ButtonsFrame(self.roiview, [&#39;Update&#39;, &#39;Max grid&#39;, &#39;Clear&#39;, &#39;Undo&#39;, &#39;New group&#39;],
                [self.update_grid, self.fill_grid, self.clear_selections, self.undo, self.new_group])

        self.roi_buttons.grid(row=8, column=1, columnspan=2)
        
        self.parview = self.tabs.tabs[2]
        self.parview.columnconfigure(1, weight=1)
        self.movemeter_settings = MovemeterSettings(self.parview)
        self.movemeter_settings.grid(column=1,sticky=&#39;NSWE&#39;)

 

        # Brightness
        self.brightness_view = self.tabs.tabs[3]
        self.brightness_view.columnconfigure(1, weight=1)
        
        self.brightness_tickboxes = {}
        for name, options in self.movemeter.measure_brightness_opt.items():
            frame = TickboxFrame(
                    self.brightness_view, options, single_select=True)
            frame.grid()
            self.brightness_tickboxes[name] = frame



        # ACTIONS FRAME
        self.actframe = tk.LabelFrame(self.opview, text=&#39;Measure&#39;)
        self.actframe.grid(row=1, column=1, columnspan=2)
        
        self.calculate_button = tk.Button(self.actframe, text=&#39;Movement&#39;,
                command=self.measure_movement)
        self.calculate_button.grid(row=1, column=1)
        
        self.brightness_do_button = tk.Button(self.actframe, text=&#39;Brightness&#39;,
                command=self.measure_brightness)
        self.brightness_do_button.grid(row=1, column=2)

        self.stop_button = tk.Button(self.actframe, text=&#39;Stop&#39;,
                command=self.stop)
        self.stop_button.grid(row=1, column=3)



        self.export_button = tk.Button(self.opview, text=&#39;Export results&#39;,
                command=self.export_results)
        self.export_button.grid(row=4, column=1)
        
        self.export_name = tk.Entry(self.opview, width=50)
        self.export_name.insert(0, &#34;enter export name&#34;)
        self.export_name.grid(row=4, column=2)
        

        # Images view: Image looking and ROI selection
        # -------------------------------------------------
        self.imview = tk.LabelFrame(self, text=&#39;Images and ROI&#39;)
        self.imview.grid(row=1, column=1, sticky=&#39;NSWE&#39;)
        
        self.imview.columnconfigure(1, weight=1)
        self.imview.rowconfigure(3, weight=1)

        self.imview_buttons = ButtonsFrame(self.imview,
                [&#39;Exclude image&#39;, &#39;Exclude index&#39;],
                [self.toggle_exclude, lambda: self.toggle_exclude(by_index=True)])
        
        self.imview_buttons.grid(row=1, column=1)


        self.image_slider = tk.Scale(self.imview, from_=0, to=0,
                orient=tk.HORIZONTAL, command=self.change_image)
        
        self.image_slider.grid(row=2, column=1, sticky=&#39;NSWE&#39;)

        self.images_plotter = CanvasPlotter(self.imview)
        self.images_plotter.grid(row=3, column=1, sticky=&#39;NSWE&#39;) 
        
        ax = self.images_plotter.ax
        self.excludetext = ax.text(0.5, 0.5, &#39;&#39;, transform=ax.transAxes,
                fontsize=24, ha=&#39;center&#39;, va=&#39;center&#39;, color=&#39;red&#39;)



        # Results view: Analysed traces
        # ------------------------------------
        
        self.tabs = Tabs(self, [&#39;Displacement&#39;, &#39;Heatmap&#39;])
        self.tabs.grid(row=1, column=2, sticky=&#39;NSWE&#39;)
        self.resview = self.tabs.pages[0]
        self.heatview = self.tabs.pages[1]

        self.resview.rowconfigure(2, weight=1)
        self.resview.columnconfigure(1, weight=1)
        self.heatview.columnconfigure(2, weight=1)
        self.heatview.rowconfigure(2, weight=1)

        self.results_plotter = CanvasPlotter(self.resview)
        self.results_plotter.grid(row=2, column=1, sticky=&#39;NSWE&#39;)
       
        # Results show options
        self.results_plotter_opts = TickboxFrame(
                self.resview,
                [&#39;show_individual&#39;, &#39;show_mean&#39;, &#39;show_toolbar&#39;],
                defaults=[True,True,False],
                callback=self.plot_results)
        self.results_plotter_opts.grid(row=1, column=1, sticky=&#39;NSWE&#39;)

        self.heatmap_plotter = CanvasPlotter(self.heatview)
        self.heatmap_plotter.grid(row=2, column=2, sticky=&#39;NSWE&#39;) 
        
        self.heatmap_slider = tk.Scale(self.heatview, from_=0, to=0,
            orient=tk.HORIZONTAL, command=self.change_heatmap)
        self.heatmap_slider.grid(row=0, column=1, sticky=&#39;NSWE&#39;)
        
        self.heatmapcap_slider = tk.Scale(self.heatview, from_=0.1, to=100,
            orient=tk.HORIZONTAL, resolution=0.1, command=self.change_heatmap)
        self.heatmapcap_slider.set(20)
        self.heatmapcap_slider.grid(row=0, column=2, sticky=&#39;NSWE&#39;) 
        
        self.heatmap_firstcap_slider = tk.Scale(self.heatview, from_=0.1, to=100,
            orient=tk.HORIZONTAL, resolution=0.1, command=self.change_heatmap)
        self.heatmap_firstcap_slider.set(20)
        self.heatmap_firstcap_slider.grid(row=1, column=2, sticky=&#39;NSWE&#39;) 
       
        
        self.status = tk.Label(self, text=&#39;Nothing to do&#39;)
        self.status.grid(row=2, column=1, columnspan=2)

        self.columnconfigure(1, weight=1)    
        self.columnconfigure(2, weight=1)
        self.rowconfigure(1, weight=1)
    

    def _imread(self, fn):
        &#39;&#39;&#39;
        Use Movemeter to open image/video.
        &#39;&#39;&#39;
        images = self.movemeter._imread(fn)
        return images


    def stop():
        &#39;&#39;&#39;
        Stop any ongoing motion analysis.
        &#39;&#39;&#39;
        self.exit=True
        if self.movemeter:
            self.movemeter.stop()


    def set_fs(self, fs=None):
        &#39;&#39;&#39;
        Opens a dialog to set the image sampling frequency (frame rate) so that
        time axises come correctly.
        &#39;&#39;&#39;
        if fs is None:
            fs = simpledialog.askfloat(&#39;Imaging frequency (Hz)&#39;, &#39;How many images were taken per second&#39;)

        if fs:
            self.fs = fs
            self.fs_button.configure(text=&#39;fs = {} Hz&#39;.format(self.fs))


    def open_settings(self):
        &#39;&#39;&#39;
        Placeholder for the settings dialog.
        &#39;&#39;&#39;
        raise NotImplementedError


    def open_directory(self, directory=None):
        &#39;&#39;&#39;
        Open a dialog to select a data directory and adds it to the
        list of open directories.
        &#39;&#39;&#39;
        if directory is None:
            try: 
                with open(os.path.join(MOVEDIR, &#39;last_directory.txt&#39;), &#39;r&#39;) as fp:
                    previous_directory = fp.read().rstrip(&#39;\n&#39;)
            except FileNotFoundError:
                previous_directory = os.getcwd()

            print(previous_directory)

            if os.path.exists(previous_directory):
                directory = filedialog.askdirectory(title=&#39;Select directory with the images&#39;, initialdir=previous_directory)
            else:
                directory = filedialog.askdirectory(title=&#39;Select directory with the images&#39;)
            
            
        if directory:
            if not os.path.isdir(MOVEDIR):
                os.makedirs(MOVEDIR)
            with open(os.path.join(MOVEDIR, &#39;last_directory.txt&#39;), &#39;w&#39;) as fp:
                fp.write(directory)
            
            # Check if folder contains any images; If not and it contains folders, append
            # The folders in this folder

            contents = os.listdir(directory)
            noimages = [fn for fn in os.listdir(directory) if fn.endswith(self.filename_extensions)] == []
            has_subfolders = any([os.path.isdir(os.path.join(directory, fn)) for fn in contents])
            
            if noimages and has_subfolders:
                directories = [os.path.join(directory, fn) for fn in os.listdir(directory)]
                self.set_status(&#39;Added {} new directories&#39;.format(len(directories)))
            else:
                directories = [directory]
                self.set_status(&#39;Added directory {}&#39;.format(directory))
            
            for directory in directories:
                self.folders.append(directory)
                self.folders_listbox.set_selections(self.folders)
                self.folder_selected(directory)

    
    def remove_directory(self):
        &#39;&#39;&#39;
        Closes a directory from the list of open data directories.
        &#39;&#39;&#39;
        self.folders.remove(self.current_folder)
        self.folders_listbox.set_selections(self.folders)

        self.set_status(&#39;Closed directory {}&#39;.format(self.current_folder))


    def folder_selected(self, folder):
        &#39;&#39;&#39;
        When the user selects a folder from the list of open data
        directories (that is self.folders_listbox)
        &#39;&#39;&#39;
        
        self.current_folder = folder

        print(&#39;Selected folder {}&#39;.format(folder))

        self.image_fns = [os.path.join(folder, fn) for fn in os.listdir(folder) if fn.endswith(self.filename_extensions)]

        self.image_fns.sort()
        

        self.N_frames = {}
        total_frames = 0
        for fn in self.image_fns:
            N = len(self._imread(fn))
            total_frames += N
            if N &gt; 1:
                self.N_frames[fn] = N

        N_images = total_frames

        self.images = [None for i in range(N_images)]
        self.mask_image = None
   

        self.change_image(slider_value=1)
        self.image_slider.config(from_=1, to=N_images)
       
        self.export_name.delete(0, tk.END)
        self.export_name.insert(0, os.path.basename(folder.rstrip(&#39;/&#39;)))


    def toggle_exclude(self, by_index=False):
        &#39;&#39;&#39;
        Look at the currently shown image and toggle its excludance.
        
        Arguments
        ---------
        by_index : bool
            If true, toggle exclude for all images with this index.
            If false, exclude the filename only.
        &#39;&#39;&#39;

        indx = int(self.image_slider.get()) - 1
        if by_index:
            fn = indx
        else:
            fn = self.image_fns[indx]

        if fn not in self.exclude_images:
            self.exclude_images.append(fn)
            self.set_status(&#39;Removed image {} from the analysis&#39;.format(fn))
        else:
            self.exclude_images.remove(fn) 
            self.set_status(&#39;Added image {} back to the analysis&#39;.format(fn))
        
        self.mask_image = None
        self.change_image(slider_value=self.image_slider.get())
    

    def toggle_controls(self):
        &#39;&#39;&#39;
        Show/hide image brightness/contrast controls.
        &#39;&#39;&#39;
        self.show_controls = not(self.show_controls)
        self.change_image()


    def recalculate_old(self, directory=None):
        &#39;&#39;&#39;
        Load old movzip, look the ROI extremes, and draw a new ROI
        but using the current block settings (block size and distance).

        Useful for testing how the results change when the selected
        area remains approximately the same but the block settings change.
        &#39;&#39;&#39;

        if directory == None:
            directory = filedialog.askdirectory()
            if not directory:
                return None
        
        if not self._ask_batchname():
            return None
 
        self.exit = False
        for root, dirs, fns in os.walk(directory):
            
            if self.exit:
                break

            movzip = [fn for fn in os.listdir(root) if fn.startswith(&#39;movemeter&#39;) and fn.endswith(&#39;.zip&#39;)]
            
            if movzip:
                settings, filenames, selections, rois, movements = self._load_movzip(os.path.join(root, movzip[0]))
                
                self.folder_selected(os.path.dirname(filenames[0]))
                
                x1, y1 = np.min(rois, axis=0)[0:2]
                x2, y2 = np.max(rois, axis=0)[0:2] + rois[0][3]
                self.set_roi(x1,y1,x2,y2)

                self.measure_movement()

                self.export_results(batch_name=self.batch_name)

        self.set_status(&#39;Results recalculated :)&#39;)


    def replot_heatmap(self, directory=None):
        &#39;&#39;&#39;
        Like recalculate old, but relies in the old movement analysis results
        &#39;&#39;&#39;
        if directory == None:
            directory = filedialog.askdirectory()
            if not directory:
                return None
        
        if not self._ask_batchname():
            return None
 
        self.exit = False
        for root, dirs, fns in os.walk(directory):
            
            if self.exit:
                break

            movzip = [fn for fn in os.listdir(root) if fn.startswith(&#39;movemeter&#39;) and fn.endswith(&#39;.zip&#39;)]
            if movzip:
                settings, filenames, self.selections, self.roi_groups, self.results = self._load_movzip(os.path.join(root, movzip[0])) 
                
                self.folder_selected(os.path.dirname(filenames[0]))
                self.set_settings(settings)

                self.plot_results()
                self.calculate_heatmap()
                self.change_heatmap(1)

                self.export_results(batch_name=self.batch_name)

        self.set_status(&#39;Heatmaps replotted :)&#39;)

    
    def _ask_batchname(self):
        name = simpledialog.askstring(&#39;Batch name&#39;, &#39;Name new folder&#39;)
        if name:
            self.batch_name = name
            return True
        else:
            return False


    def batch_process(self, fill_maxgrid=False):
        &#39;&#39;&#39;
        fill_maxgrid : bool
            If True, ignore current ROIs and fill a full frame grid
            using the current slider options.
        &#39;&#39;&#39;

        if not self._ask_batchname():
            return None
        
        self.exit = False
        for folder in self.folders:
            if self.exit:
                break
            self.folder_selected(folder)
            
            if fill_maxgrid:
                self.fill_grid()
            
            self.measure_movement()
            self.export_results(batch_name=self.batch_name)


    def measure_movement(self, target=None):
        &#39;&#39;&#39;
        Run motion analysis for the images in the currently selected
        directory, using the drawn ROIs.
        &#39;&#39;&#39;

        if target is None:
            target = lambda: self.movemeter.measure_movement(0, optimized=True)

        if self.image_fns and self.roi_groups:
            print(&#39;Started roi measurements&#39;)
           
            self.results = []
            
            self.movemeter = Movemeter(print_callback=self.set_status,
                    **self.movemeter_settings.get_current())
           
            for rois in self.roi_groups:
                # Set movemeted data
                images = [self._included_image_fns()]
                self.movemeter.set_data(images, [rois])
                
                self.results.append( target() )
            
            self.plot_results()

            self.calculate_heatmap()
            self.change_heatmap(1)

        else:
            self.set_status(&#39;No images or ROIs selected&#39;)
    
    def measure_brightness(self):
        kwargs = {}
        for name, frame in self.brightness_tickboxes.items():
            kwargs[name] = frame.ticked[0]

        bmes = lambda: self.movemeter.measure_brightness(0, **kwargs)
        self.measure_movement(target=bmes)

    @property
    def image_shape(self):
        slider_value = int(self.image_slider.get())
        image_i = int(slider_value) -1
        if self.images[image_i] is None:
            self.images[image_i] = self._imread(self.image_fns[image_i])[0]
        return self.images[image_i].shape

    
    def open_colormap_selection(self):
        &#39;&#39;&#39;
        Start ColormapSelector widget in a toplevel window.
        &#39;&#39;&#39;
        top = tk.Toplevel(self)
        top.title(&#39;Select colormap&#39;)
        sel = ColormapSelector(top, callback=self.apply_colormap,
                startmap=self.colors.get_cmap().name)
        sel.grid(row=0, column=0, sticky=&#39;NSWE&#39;)
        top.rowconfigure(0, weight=1)
        top.columnconfigure(0, weight=1)
        top.mainloop()


    def apply_colormap(self, colormap):
        if hasattr(colormap, &#39;colors&#39;):
            self.colors.set_clim(0, len(colormap.colors))
        else:
            self.colors.set_clim(0, 10)

        self.colors.set_cmap(colormap)
        self.colormap_selection.config(text=colormap.name)
        self.update_grid()


    def undo(self):
        &#39;&#39;&#39;
        Undo a ROI selection made by the user.
        &#39;&#39;&#39;
        if len(self.selections) == 0:
            self.set_status(&#39;Nothing to undo&#39;)
            return None

        # Index of the roigroup to be undone
        i_roigroup = self.selections[-1][-1][&#39;i_roigroup&#39;]

        # Clear the previous selection data
        self.selections = self.selections[:-1]
        
        # Clear the corresponding ROI patches
        N_rois_remove = len(self.roi_patches[-1])
        for patch in self.roi_patches[-1]:
            patch.remove()
        self.roi_patches = self.roi_patches[:-1]
        
        # Clear the actual ROIs
        self.roi_groups[i_roigroup] = self.roi_groups[i_roigroup][:-N_rois_remove]
        
        self.images_plotter.update()
        self.set_status(&#39;Undone windows {} in ROI group {}&#39;.format(N_rois_remove, i_roigroup))


    def update_roitype_selection(self):
        &#39;&#39;&#39;
        When user selects a certain ROI type (box, circle, ...) to draw
        some of the sliders can be hidden.
        &#39;&#39;&#39;
        selected = self.roitype_selection.ticked[0] 

        if selected in [&#39;concentric_arcs_from_points&#39;, &#39;radial_lines_from_points&#39;]:
            self.nroi_label.grid()
            self.nroi_slider.grid()

            if selected == &#39;radial_lines_from_points&#39;:
                self.radial_len_label.grid()
                self.radial_len_slider.grid()

        else:
            self.nroi_label.grid_remove()
            self.nroi_slider.grid_remove()

            self.radial_len_label.grid_remove()
            self.radial_len_slider.grid_remove()

        self.change_image()


    def clear_selections(self):
        &#39;&#39;&#39;
        Clear current user selections and ROIs (fresh start)
        &#39;&#39;&#39;
        self.selections = []
        self.update_grid()

        self.roi_groups = []
        self.current_roi_group = 0


    def update_grid(self, *args):

        # Updating the image also needed now to update the selector
        # type drawn while selecting (box or line)
        self.change_image()
        
        # Clear any previous patches
        for group in self.roi_patches:
            for patch in group:
                patch.remove()
        self.roi_patches = []

        self.roi_groups = []
        
        if self.selections:
            for selection in self.selections:
                self.set_roi(*selection, user_made=False)
        else:
            self.images_plotter.update()


    def fill_grid(self):
        &#39;&#39;&#39;
        Create a selection spanning the whole image and distribute
        cross-correlation windows everywhere.
        &#39;&#39;&#39;
        self.set_roi(0,0,*reversed(self.image_shape))

    def new_group(self):
        &#39;&#39;&#39;
        Advance to the next ROI group.
        &#39;&#39;&#39;
        self.current_roi_group += 1


    def set_roi(self, x1=None,y1=None,x2=None,y2=None, params=None, user_made=True,
            recursion_data=None):
        &#39;&#39;&#39;
        Add (or &#34;remove&#34;) a ROI based on user selection.

        Arguments
        ---------
        x1, y1, x2, y2 : None or int
        params : none or dict
        user_made : bool
            Is this an user made selection.
        recursion_data : None or something
            Internal use.
        &#39;&#39;&#39;

        if params is None:
            params = {}
            params[&#39;roitype&#39;] = [s for s, b in self.roitype_selection.states.items() if b][0]
            params[&#39;blocksize&#39;] = 2*[self.blocksize_slider.get()]
            params[&#39;distance&#39;] = self.distance_slider.get()
            params[&#39;relstep&#39;] = float(self.overlap_slider.get())/params[&#39;blocksize&#39;][0]
            params[&#39;count&#39;] = self.nroi_slider.get()
            params[&#39;rlen&#39;] = self.radial_len_slider.get()
            params[&#39;i_roigroup&#39;] = int(self.current_roi_group)
            params[&#39;mode&#39;] = self.drawmode_selection.ticked[0]

       
        roitype, block_size, distance, rel_step, i_roigroup, count, mode, rlen = [
                params[key] for key in [&#39;roitype&#39;,&#39;blocksize&#39;,&#39;distance&#39;,&#39;relstep&#39;, &#39;i_roigroup&#39;, &#39;count&#39;, &#39;mode&#39;, &#39;rlen&#39;]]

        if user_made:
            self.selections.append( (x1, y1, x2, y2, params) )   
        
        if roitype in [&#39;polygon&#39;, &#39;arc_from_points&#39;, &#39;concentric_arcs_from_points&#39;,
                &#39;radial_lines_from_points&#39;]:
            vertices = x1

            if roitype == &#39;polygon&#39;:
                rois = []
                for i_vertex in range(len(vertices)-1):
                    pA, pB = vertices[i_vertex:i_vertex+2]
                    rois.extend( grid_along_line(pA, pB, distance, block_size, step=rel_step) )
            elif roitype == &#39;arc_from_points&#39;:
                rois = grid_arc_from_points((0,0,*reversed(self.image_shape)), block_size, step=rel_step, points=vertices)
            elif roitype in [&#39;concentric_arcs_from_points&#39;, &#39;radial_lines_from_points&#39;]:
                if recursion_data is None:
                    recursion_data = _workout_circle(vertices)
                
                if int(self.current_roi_group) &lt; count-1:
                    self.current_roi_group += 1
                    cp, R = recursion_data
                    
                    if roitype == &#39;concentric_arcs_from_points&#39;:
                        new_recursion_data = (cp, R-distance)
                    elif roitype == &#39;radial_lines_from_points&#39;:
                        new_recursion_data = (cp, R)

                    self.set_roi(x1=x1,y1=y1,x2=x2,y2=y2,
                            params={**params, **{&#39;i_roigroup&#39;: self.current_roi_group}},
                            user_made=False,
                            recursion_data=new_recursion_data)
                    self.current_roi_group -= 1 
                
                if roitype == &#39;concentric_arcs_from_points&#39;:
                    rois = grid_arc_from_points((0,0,*reversed(self.image_shape)), block_size, step=rel_step,
                            circle=recursion_data, lw=distance)
                elif roitype == &#39;radial_lines_from_points&#39;:
                    rois = grid_radial_line_from_points((0,0,*reversed(self.image_shape)), block_size, step=rel_step,
                            circle=recursion_data, line_len=rlen,
                            i_segment=self.current_roi_group, n_segments=count)

            else:
                raise ValueError(&#39;unkown roitype {}&#39;.format(roitype))

        else:
            w = x2-x1
            h = y2-y1
       
            if roitype == &#39;line&#39;:
                rois = grid_along_line((x1, y1), (x2, y2), distance, block_size, step=rel_step)
            elif roitype == &#39;ellipse&#39;:
                rois = grid_along_ellipse((x1,y1,w,h), block_size, step=rel_step)
            else:
                rois = gen_grid((x1,y1,w,h), block_size, step=rel_step)
            
        while len(self.roi_groups) &lt;= i_roigroup:
            self.roi_groups.append([])

        if mode == &#39;add&#39;:
            self.roi_groups[i_roigroup].extend(rois)
     
            # Draw ROIs

            if len(rois) &lt; 3000:
                self.set_status(&#39;Plotting all ROIs...&#39;)
            else:
                self.set_status(&#39;Too many ROIs, plotting only 3 000 first...&#39;)
            
            fig, ax = self.images_plotter.get_figax()
            
            color = self.colors.to_rgba(i_roigroup%self.colors.get_clim()[1])
            
            patches = [] 
            lw = self.patch_lw_slider.get()
            fill = self.patch_fill_slider.get()/100
            fcolor = (color[0], color[1], color[2], color[3]*fill)
            for roi in rois[:3000]:

                patch = matplotlib.patches.Rectangle((float(roi[0]), float(roi[1])),
                        float(roi[2]), float(roi[3]), fill=True, edgecolor=color, facecolor=fcolor,
                        lw=lw)
                patches.append(patch)
                ax.add_patch(patch)
            
            self.roi_patches.append(patches)

        elif mode == &#39;remove&#39;:
            
            def _overlaps(a, b):
                return not (a[0]+a[2] &lt; b[0] or b[0]+b[2] &lt; a[0] or a[1]+a[3] &lt; b[1] or b[1]+b[3] &lt; a[1])

            for i_rgroup in range(len(self.roi_groups)) :
                
                # Remove ROIs
                remove_indices = []
                for i_old, old_roi in enumerate(self.roi_groups[i_rgroup]):    
                    for new_roi in rois:
                        if _overlaps(old_roi, new_roi):
                            remove_indices.append(i_old)
                            break
                
                print(&#39;removing {} in rg {}&#39;.format(remove_indices, i_rgroup))

                for i_rm in remove_indices[::-1]:
                    self.roi_groups[i_rgroup].pop()

                    #self.roi_patches[i_rgroup].pop()
                
            # Remove patches separetly
            # Potential optimization if needed: Not sure if this is faster or
            #    slower than the own _overlaps
            # Anyway quite risky if rois and patches become unsynced
            #    (should be made in one-to-one correspondence)
            new_bboxes = [matplotlib.transforms.Bbox([[x, y],[x+w,y+h]]) for x,y,w,h in rois]
            for patches, selections in zip(self.roi_patches, self.selections):
                
                remove_indices = []
                for i_patch, patch in enumerate(patches):
                    if patch.get_bbox().count_overlaps(new_bboxes):
                        patch.remove()
                        remove_indices.append(i_patch)

                for i_rm in remove_indices[::-1]:
                    patches.pop(i_rm)


        else:
            raise ValueError(&#39;unkown mode {}&#39;.format(mode))
        self.images_plotter.update()
        self.set_status(&#39;ROIs plotted :)&#39;)


    def _get_fn_and_frame(self, i_image):
        &#39;&#39;&#39;
        Workaround needed for video/stack files, getting the correct
        filename and frame for the ith image.

        Arguments
        ---------
        i_image : int
            Index of the image.

        Returns
        -------
        i_fn : int
            Index of the file name in self.image_fns
        i_frame : int
            Index of the frame in the video/stack file.
        &#39;&#39;&#39;
        total_frames = 0
        for i_fn, fn in enumerate(self.image_fns):
            frames = self.N_frames.get(fn, 1)
            total_frames += frames

            if total_frames &gt;= i_image:
                return i_fn, frames - (total_frames - i_image) - 1
    

    def change_image(self, slider_value=None):
        &#39;&#39;&#39;
        Change the currently shown data image.
        &#39;&#39;&#39;
        slider_value = int(self.image_slider.get())

        image_i = int(slider_value) -1

        if not 0 &lt;= image_i &lt; len(self.images):
            return None
        
        if self.use_mask_image:
            if self.mask_image is None:
                for i in range(len(self.images)):

                    self.images[i] = self._imread(self.image_fns[i])
                
                self.mask_image = np.inf * np.ones(self.image_shape)
                
                for image in self.images:
                    self.mask_image = np.min([self.mask_image, image], axis=0)


        i_fn, i_frame = self._get_fn_and_frame(image_i)
        
        if self.images[image_i] is None:
            self.images[image_i] = self._imread(self.image_fns[i_fn])[i_frame] 
        
        if image_i in self.exclude_images or self.image_fns[i_fn] in self.exclude_images:
            self.excludetext.set_text(&#39;EXCLUDED&#39;)
        else: 
            self.excludetext.set_text(&#39;&#39;)


        if self.use_mask_image:
            showimage = self.images[image_i] - self.mask_image
        else:
            showimage = self.images[image_i]

        self.images_plotter.imshow(showimage, roi_callback=self.set_roi,
                cmap=&#39;gray&#39;, slider=self.show_controls,
                roi_drawtype=self.roi_drawtypes[self.roitype_selection.ticked[0]])


    @staticmethod
    def get_displacements(results):
        &#39;&#39;&#39;
        Returns the directionless mangitude of the motion (displacement).
        &#39;&#39;&#39;
        return [np.sqrt(np.array(x)**2+np.array(y)**2) for x,y in results]


    @staticmethod
    def get_destructive_displacement_mean(results):
        &#39;&#39;&#39;
        Takes first the mean of the x and y components separately, and then
        calculates the directionless magnitude (displacement).

        This way the &#34;random walk&#34; does not pollute the mean so much as when
        taking the mean of the directionless magnitudes.
        &#39;&#39;&#39;
        x = [x for x,y in results]
        y = [y for x,y in results]
        return np.sqrt(np.mean(x, axis=0)**2 + np.mean(y, axis=0)**2)


    def plot_results(self):
        &#39;&#39;&#39;
        Plots (time, displacement).
        &#39;&#39;&#39;

        self.results_plotter.set_toolbar_visibility(
                &#39;show_toolbar&#39; in self.results_plotter_opts.ticked)

        self.results_plotter.ax.clear()

        for i_roi_group, result in enumerate(self.results):
            color = self.colors.to_rgba(i_roi_group%self.colors.get_clim()[1])
            displacements = [np.sqrt(np.array(x)**2+np.array(y)**2) for x,y in result]
            
            if &#39;show_individual&#39; in self.results_plotter_opts.ticked:
                N_toplot = max( len(displacements), 50 )
                for d in displacements[0:N_toplot]:
                    self.results_plotter.plot(d, ax_clear=False, color=color, lw=0.5)
            
            if &#39;show_mean&#39; in self.results_plotter_opts.ticked:
                self.results_plotter.plot(self.get_destructive_displacement_mean(result), ax_clear=False, color=color, lw=2)


    def _included_image_fns(self):
        return [fn for i_fn, fn in enumerate(self.image_fns) if fn not in self.exclude_images and i_fn not in self.exclude_images]
    

    def _len_included_frames(self):
        return sum([self.N_frames.get(fn, 1) for fn in self._included_image_fns()])


    def calculate_heatmap(self):
        &#39;&#39;&#39;
        Produce minimum size heatmap.
        &#39;&#39;&#39;
        self.heatmap_images = []
        
        # FIXME Heatmap for ROI groups not implemented properly
        # Currently just take the first nonempty ROI group
        i_roigroup = [i for i, rois in enumerate(self.roi_groups) if len(rois) != 0]
        if not i_roigroup:
            return None
        else:
            i_roigroup = i_roigroup[0]
        rois = self.roi_groups[i_roigroup]
        results = self.results[i_roigroup]

        roi_w, roi_h = rois[0][2:]

        roi_max_x = np.max([z[0] for z in rois])
        roi_min_x = np.min([z[0] for z in rois])
        roi_max_y = np.max([z[1] for z in rois])
        roi_min_y = np.min([z[1] for z in rois])
        
        step = int(self.overlap_slider.get())
        
        max_movement = float(self.movemeter_settings.maxmovement_slider.get())

        N = self._len_included_frames()

        for i_frame in range(N):
            image = np.zeros( (int((roi_max_y-roi_min_y)/step)+1, int((roi_max_x-roi_min_x)/step)+1) )
            for ROI, (x,y) in zip(rois, results):
                values = (np.sqrt(np.array(x)**2+np.array(y)**2))
                
                value = values[i_frame]
               
                cx = int((ROI[0]-roi_min_x)/step)
                cy = int((ROI[1]-roi_min_y)/step)
                
                try:
                    image[cy, cx] = value
                except:
                    print(image.shape)
                    print(&#39;cx {} cy {}&#39;.format(cx, cy))
                    raise ValueError
            if np.max(image) &lt; 0.01:
                image[0,0] = 1
            self.heatmap_images.append(image)

        self.heatmap_slider.config(from_=1, to=len(self.heatmap_images))
        self.heatmap_slider.set(1) 
        
        maxcapval = np.max(self.heatmap_images)
        self.heatmapcap_slider.config(from_=0, to=maxcapval)
        self.heatmapcap_slider.set(maxcapval)


    def change_heatmap(self, slider_value=None, only_return_image=False):
        &#39;&#39;&#39;
        When moving the slider to select the heatmap frame to show.
        &#39;&#39;&#39;
        #if slider_value == None:
        slider_value = int(self.heatmap_slider.get())

        i_image = int(slider_value) - 1
        image = np.copy(self.heatmap_images[i_image])
        
        # Total max value cap
        allframemax = np.max(self.heatmap_images, axis=0)
        image[allframemax &gt; float(self.heatmapcap_slider.get())] = 0
        
        # First value max cap
        firstframemax = np.max(self.heatmap_images[0:3], axis=0)
        #image[firstframemax &gt; float(self.heatmap_firstcap_slider.get())] = 0
        
        #image = image / float(self.heatmapcap_slider.get())
        #image[np.isnan(image)] = 0
        image = image / np.max(image)
        if np.isnan(image).any():
            image = np.ones(image.shape)
            image[0][0] = 0

        if only_return_image:
            return image
        else:
            self.heatmap_plotter.imshow(image, normalize=False)
   

    def set_settings(self, settings):
        &#39;&#39;&#39;
        Apply the given settings.

        Arguments
        ----------
        settings : dict
            A dictionary of settings.
        &#39;&#39;&#39;
        for key, value in settings.items():
            if key == &#39;block_size&#39;:
                self.blocksize_slider.set(value)
            elif key == &#39;block_distance&#39;:
                self.overlap_slider.set(value)
            elif key == &#39;maximum_movement&#39;:
                self.movemeter_settings.maxmovement_slider.set(value)
            elif key == &#39;upscale&#39;:
                self.movemeter_settings.upscale_slider.set(value)
            elif key == &#39;cpu_cores&#39;:
                self.movemeter_settings.cores_slider.set(value)
            elif key == &#39;exclude_images&#39;:
                self.exclude_images = value
            elif key == &#39;measurement_parameters&#39;:
                self.movemeter_settings.tickboxes.states = value


    def set_status(self, text):
        &#39;&#39;&#39;
        Shows info text at the window bottom.
        &#39;&#39;&#39;
        self.status.config(text=text)
        self.status.update_idletasks()
    

    def apply_movzip(self, fn=None, rois=False):
        &#39;&#39;&#39;
        Load parts of a movzip and apply settings from it
        to the current session.
        &#39;&#39;&#39;
        if fn is None:
            fn = filedialog.askopenfilename(parent=self, title=&#39;Select a movzip&#39;,
                    initialdir=MOVEDIR)

        settings, filenames, selections, roi_groups, movements = self._load_movzip(fn)
        
        if rois:
            self.selections = selections
            self.rois_groups = roi_groups
            self.update_grid()


    def _save_movzip(self, fn=None, only=None):
        &#39;&#39;&#39;
        Saves a movzip containg data/settings about the ran motion analysis.
        
        Arguments
        ---------
        fn : string or None
            If None, ask the filename.
        only : bool, string or list of strings
            Select to save only certain parts.
            Possible values are &#39;metadata&#39;, &#39;image_filenames&#39;, &#39;selections&#39;,
            &#39;rois&#39;, &#39;movements&#39; or any list combinations of these.
        &#39;&#39;&#39;

        if isinstance(only, str):
            only = [only]

        if fn is None:
            if only:
                title = &#39;Save &#39;+&#39;,&#39;.join(only)
            else:
                title = &#39;Save movzip&#39;
            fn = filedialog.asksaveasfilename(parent=self, title=title,
                    initialdir=MOVEDIR)
            
            if not fn.endswith(&#39;.zip&#39;):
                fn = fn+&#39;.zip&#39;

        # Dump GUI settings
        settings = {}
        settings[&#39;block_size&#39;] = self.blocksize_slider.get()
        settings[&#39;block_distance&#39;] = self.overlap_slider.get()
        settings[&#39;movemeter_settings&#39;] = self.movemeter_settings.get_current()
        settings[&#39;export_time&#39;] = str(datetime.datetime.now())
        settings[&#39;movemeter_version&#39;] = __version__
        settings[&#39;exclude_images&#39;] = self.exclude_images

        if self.images:
            settings[&#39;images_shape&#39;] = self.image_shape
        
        
        movzip = {&#39;metadata&#39;: settings,
                &#39;image_filenames&#39;: self._included_image_fns(),
                &#39;selections&#39;: self.selections,
                &#39;rois&#39;: self.roi_groups,
                &#39;movements&#39;: self.results}

        self.set_status(&#39;Saving movzip...&#39;)
        
        with zipfile.ZipFile(fn, &#39;w&#39;) as savezip:
            for pfn, obj in movzip.items():

                if only and pfn not in only:
                    continue

                with savezip.open(pfn+&#39;.json&#39;, &#39;w&#39;) as fp:
                    fp.write(json.dumps(obj).encode(&#39;utf-8&#39;))
        
        self.set_status(&#39;Mozip saved.&#39;)
        


    def _load_movzip(self, fn):
        &#39;&#39;&#39;
        Load a movzip, returning its contents.

        Returns
        -------
        settings, image_filenames, selections, rois, movements
        &#39;&#39;&#39;

        movzip = []

        with zipfile.ZipFile(fn, &#39;r&#39;) as loadzip:
            
            for pfn in [&#39;metadata&#39;, &#39;image_filenames&#39;, &#39;selections&#39;, &#39;rois&#39;, &#39;movements&#39;]:
                try:
                    with loadzip.open(pfn+&#39;.json&#39;, &#39;r&#39;) as fp:
                        movzip.append( json.loads(fp.read()) )
        
                except KeyError:
                    movzip.append(None)

        return (*movzip,)

    
    def save_roiview(self, only_rois=False):
        &#39;&#39;&#39;
        Save the current image view with ROIs.

        Arguments
        ---------
        only_rois : bool
            If True, hide the image and show ROIs in the
            saved image.
        &#39;&#39;&#39;
        savefn = filedialog.asksaveasfilename()
        if savefn:
            fig = self.images_plotter.figure
            
            if only_rois:
                self.images_plotter.imshow_obj.set_visible(False)
            
            fig.savefig(savefn, dpi=600, transparent=only_rois)
            
            if only_rois:
                self.images_plotter.imshow_obj.set_visible(True)



    def export_results(self, batch_name=None):
        &#39;&#39;&#39;
        Creates a folder containing motion analysis results
        - movzip
        - csv files
        - images
        &#39;&#39;&#39;
        savename = self.export_name.get()
        zipsavename = savename

        save_root = MOVEDIR
        if batch_name is not None:
            save_root = os.path.join(save_root, &#39;batch&#39;, batch_name)
        
        save_directory = os.path.join(save_root, savename)
        os.makedirs(save_directory, exist_ok=True)
    
        self._save_movzip(os.path.join(save_directory, &#39;movemeter_{}.zip&#39;.format(zipsavename)))
        
        means = []

        for i_roigroup, results in enumerate(self.results):
            fn = os.path.join(save_directory, &#39;movements_{}_rg{}.csv&#39;.format(zipsavename, i_roigroup))
            
            displacements = self.get_displacements(results)
            
            if not displacements:
                continue

            dm_displacement = self.get_destructive_displacement_mean(results)

            with open(fn, &#39;w&#39;) as fp:
                writer = csv.writer(fp, delimiter=&#39;,&#39;)
                
                writer.writerow([&#39;time (s)&#39;, &#39;mean displacement (pixels)&#39;, &#39;destructive mean displacement (pixels)&#39;] + [&#39;ROI{} displacement (pixels)&#39;.format(k) for k in range(len(displacements))])

                for i in range(len(displacements[0])):
                    row = [displacements[j][i] for j in range(len(displacements))]
                    row.insert(0, dm_displacement[i])
                    row.insert(0, np.mean(row))
                    row.insert(0, i/self.fs)
                    writer.writerow(row)

                if i_roigroup == 0:
                    N = len(dm_displacement)
                    means.append(np.linspace(0, (N-1)/self.fs, N))
                means.append(dm_displacement)

        with open(os.path.join(save_directory, &#39;summary_desctructive_{}.csv&#39;.format(zipsavename)), &#39;w&#39;) as fp:
            writer = csv.writer(fp,  delimiter=&#39;,&#39;)

            writer.writerow([&#39;time (s)&#39;] +[&#39;roi group {} (pixels)&#39;.format(i) for i in range(len(means)-1)])

            for i in range(len(means[0])):
                row = [m[i] for m in means]
                writer.writerow(row)


        slider_i = int(self.image_slider.get())
        self.image_slider.set(int(len(self._included_image_fns()))/2)

        # Image of the ROIs
        self.set_status(&#39;Saving the image view&#39;)
        fig, ax = self.images_plotter.get_figax()
        fig.savefig(os.path.join(save_directory, &#39;movemeter_imageview.jpg&#39;), dpi=400, pil_kwargs={&#39;optimize&#39;: True})
        
        self.image_slider.set(slider_i)
        
        # Image of the result traces
        self.set_status(&#39;Saving the results view&#39;)
        fig, ax = self.results_plotter.get_figax()
        fig.savefig(os.path.join(save_directory, &#39;movemeter_resultsview.jpg&#39;), dpi=400, pil_kwargs={&#39;optimize&#39;: True})


        def save_heatmaps(heatmaps, image_fns, savedir):
            
            for fn, image in zip(image_fns, heatmaps):
                tifffile.imsave(os.path.join(savedir, &#39;ht_{}&#39;.format(os.path.basename(fn))), image.astype(&#39;float32&#39;))
            
            # Save mean heatmap image with scale bar using matplotlib
            # FIXME Expose option for how many last images to save the mean for
            meanimage = np.mean(heatmaps[-min(5, len(heatmaps)):], axis=0)
            
            if False:
                # This was used to clip heatmap values
                # FIXME Expose option in the GUI
                if &#39;musca&#39; in save_directory:
                    meanimage = np.clip(meanimage, 0, 50)
                    if np.max(meanimage) &lt; 50:
                        meanimage[0,0] = 50
                else:
                    meanimage = np.clip(meanimage, 0, 6)
                    if np.max(meanimage) &lt; 6:
                        meanimage[0,0] = 6

            fig, ax = plt.subplots()
            imshow = ax.imshow(meanimage)
            ax.set_axis_off()

            divider = make_axes_locatable(ax)
            cax = divider.append_axes(&#39;right&#39;, size=&#39;5%&#39;, pad=0.05)
            fig.colorbar(imshow, cax=cax)
            
            fig.savefig(os.path.join(savedir, &#39;ht_mean.png&#39;), dpi=800)
            
            plt.show(block=False)
            plt.pause(0.01)
            plt.close(fig)
        
        self.set_status(&#39;Saving heatmaps&#39;)
        subsavedir = os.path.join(save_directory, &#39;heatmap_tif&#39;)
        os.makedirs(subsavedir, exist_ok=True)
         
        save_heatmaps(self.heatmap_images, self.image_fns, subsavedir)
        
        self.set_status(&#39;DONE Saving :)&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="movemeter.tkgui.MovemeterTkGui.get_destructive_displacement_mean"><code class="name flex">
<span>def <span class="ident">get_destructive_displacement_mean</span></span>(<span>results)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes first the mean of the x and y components separately, and then
calculates the directionless magnitude (displacement).</p>
<p>This way the "random walk" does not pollute the mean so much as when
taking the mean of the directionless magnitudes.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.get_displacements"><code class="name flex">
<span>def <span class="ident">get_displacements</span></span>(<span>results)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the directionless mangitude of the motion (displacement).</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="movemeter.tkgui.MovemeterTkGui.image_shape"><code class="name">prop <span class="ident">image_shape</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def image_shape(self):
    slider_value = int(self.image_slider.get())
    image_i = int(slider_value) -1
    if self.images[image_i] is None:
        self.images[image_i] = self._imread(self.image_fns[image_i])[0]
    return self.images[image_i].shape</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="movemeter.tkgui.MovemeterTkGui.apply_colormap"><code class="name flex">
<span>def <span class="ident">apply_colormap</span></span>(<span>self, colormap)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.apply_movzip"><code class="name flex">
<span>def <span class="ident">apply_movzip</span></span>(<span>self, fn=None, rois=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Load parts of a movzip and apply settings from it
to the current session.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.batch_process"><code class="name flex">
<span>def <span class="ident">batch_process</span></span>(<span>self, fill_maxgrid=False)</span>
</code></dt>
<dd>
<div class="desc"><p>fill_maxgrid : bool
If True, ignore current ROIs and fill a full frame grid
using the current slider options.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.calculate_heatmap"><code class="name flex">
<span>def <span class="ident">calculate_heatmap</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce minimum size heatmap.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.change_heatmap"><code class="name flex">
<span>def <span class="ident">change_heatmap</span></span>(<span>self, slider_value=None, only_return_image=False)</span>
</code></dt>
<dd>
<div class="desc"><p>When moving the slider to select the heatmap frame to show.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.change_image"><code class="name flex">
<span>def <span class="ident">change_image</span></span>(<span>self, slider_value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the currently shown data image.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.clear_selections"><code class="name flex">
<span>def <span class="ident">clear_selections</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear current user selections and ROIs (fresh start)</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.export_results"><code class="name flex">
<span>def <span class="ident">export_results</span></span>(<span>self, batch_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a folder containing motion analysis results
- movzip
- csv files
- images</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.fill_grid"><code class="name flex">
<span>def <span class="ident">fill_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a selection spanning the whole image and distribute
cross-correlation windows everywhere.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.folder_selected"><code class="name flex">
<span>def <span class="ident">folder_selected</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"><p>When the user selects a folder from the list of open data
directories (that is self.folders_listbox)</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.measure_brightness"><code class="name flex">
<span>def <span class="ident">measure_brightness</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.measure_movement"><code class="name flex">
<span>def <span class="ident">measure_movement</span></span>(<span>self, target=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Run motion analysis for the images in the currently selected
directory, using the drawn ROIs.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.new_group"><code class="name flex">
<span>def <span class="ident">new_group</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Advance to the next ROI group.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.open_colormap_selection"><code class="name flex">
<span>def <span class="ident">open_colormap_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start ColormapSelector widget in a toplevel window.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.open_directory"><code class="name flex">
<span>def <span class="ident">open_directory</span></span>(<span>self, directory=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Open a dialog to select a data directory and adds it to the
list of open directories.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.open_settings"><code class="name flex">
<span>def <span class="ident">open_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Placeholder for the settings dialog.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.plot_results"><code class="name flex">
<span>def <span class="ident">plot_results</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots (time, displacement).</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.recalculate_old"><code class="name flex">
<span>def <span class="ident">recalculate_old</span></span>(<span>self, directory=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load old movzip, look the ROI extremes, and draw a new ROI
but using the current block settings (block size and distance).</p>
<p>Useful for testing how the results change when the selected
area remains approximately the same but the block settings change.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.remove_directory"><code class="name flex">
<span>def <span class="ident">remove_directory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Closes a directory from the list of open data directories.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.replot_heatmap"><code class="name flex">
<span>def <span class="ident">replot_heatmap</span></span>(<span>self, directory=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Like recalculate old, but relies in the old movement analysis results</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.save_roiview"><code class="name flex">
<span>def <span class="ident">save_roiview</span></span>(<span>self, only_rois=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the current image view with ROIs.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>only_rois</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, hide the image and show ROIs in the
saved image.</dd>
</dl></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.set_fs"><code class="name flex">
<span>def <span class="ident">set_fs</span></span>(<span>self, fs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a dialog to set the image sampling frequency (frame rate) so that
time axises come correctly.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.set_roi"><code class="name flex">
<span>def <span class="ident">set_roi</span></span>(<span>self, x1=None, y1=None, x2=None, y2=None, params=None, user_made=True, recursion_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add (or "remove") a ROI based on user selection.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>x1</code></strong>, <strong><code>y1</code></strong>, <strong><code>x2</code></strong>, <strong><code>y2</code></strong> :&ensp;<code>None</code> or <code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>none</code> or <code>dict</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>user_made</code></strong> :&ensp;<code>bool</code></dt>
<dd>Is this an user made selection.</dd>
<dt><strong><code>recursion_data</code></strong> :&ensp;<code>None</code> or <code>something</code></dt>
<dd>Internal use.</dd>
</dl></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.set_settings"><code class="name flex">
<span>def <span class="ident">set_settings</span></span>(<span>self, settings)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the given settings.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of settings.</dd>
</dl></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.set_status"><code class="name flex">
<span>def <span class="ident">set_status</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows info text at the window bottom.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop any ongoing motion analysis.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.toggle_controls"><code class="name flex">
<span>def <span class="ident">toggle_controls</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Show/hide image brightness/contrast controls.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.toggle_exclude"><code class="name flex">
<span>def <span class="ident">toggle_exclude</span></span>(<span>self, by_index=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Look at the currently shown image and toggle its excludance.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>by_index</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, toggle exclude for all images with this index.
If false, exclude the filename only.</dd>
</dl></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Undo a ROI selection made by the user.</p></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.update_grid"><code class="name flex">
<span>def <span class="ident">update_grid</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="movemeter.tkgui.MovemeterTkGui.update_roitype_selection"><code class="name flex">
<span>def <span class="ident">update_roitype_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When user selects a certain ROI type (box, circle, &hellip;) to draw
some of the sliders can be hidden.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href='../index.html'><- Back to All Docs</a><br>
<a href="javascript:history.back()"><- Back one page</a>
<div class="toc">
<ul>
<li><a href="#features-in-short">Features in short</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="movemeter" href="index.html">movemeter</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="movemeter.tkgui.main" href="#movemeter.tkgui.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="movemeter.tkgui.ColormapSelector" href="#movemeter.tkgui.ColormapSelector">ColormapSelector</a></code></h4>
<ul class="">
<li><code><a title="movemeter.tkgui.ColormapSelector.on_ok" href="#movemeter.tkgui.ColormapSelector.on_ok">on_ok</a></code></li>
<li><code><a title="movemeter.tkgui.ColormapSelector.on_selection" href="#movemeter.tkgui.ColormapSelector.on_selection">on_selection</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movemeter.tkgui.MovemeterSettings" href="#movemeter.tkgui.MovemeterSettings">MovemeterSettings</a></code></h4>
<ul class="">
<li><code><a title="movemeter.tkgui.MovemeterSettings.get_current" href="#movemeter.tkgui.MovemeterSettings.get_current">get_current</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movemeter.tkgui.MovemeterTkGui" href="#movemeter.tkgui.MovemeterTkGui">MovemeterTkGui</a></code></h4>
<ul class="">
<li><code><a title="movemeter.tkgui.MovemeterTkGui.apply_colormap" href="#movemeter.tkgui.MovemeterTkGui.apply_colormap">apply_colormap</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.apply_movzip" href="#movemeter.tkgui.MovemeterTkGui.apply_movzip">apply_movzip</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.batch_process" href="#movemeter.tkgui.MovemeterTkGui.batch_process">batch_process</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.calculate_heatmap" href="#movemeter.tkgui.MovemeterTkGui.calculate_heatmap">calculate_heatmap</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.change_heatmap" href="#movemeter.tkgui.MovemeterTkGui.change_heatmap">change_heatmap</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.change_image" href="#movemeter.tkgui.MovemeterTkGui.change_image">change_image</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.clear_selections" href="#movemeter.tkgui.MovemeterTkGui.clear_selections">clear_selections</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.export_results" href="#movemeter.tkgui.MovemeterTkGui.export_results">export_results</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.fill_grid" href="#movemeter.tkgui.MovemeterTkGui.fill_grid">fill_grid</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.folder_selected" href="#movemeter.tkgui.MovemeterTkGui.folder_selected">folder_selected</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.get_destructive_displacement_mean" href="#movemeter.tkgui.MovemeterTkGui.get_destructive_displacement_mean">get_destructive_displacement_mean</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.get_displacements" href="#movemeter.tkgui.MovemeterTkGui.get_displacements">get_displacements</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.image_shape" href="#movemeter.tkgui.MovemeterTkGui.image_shape">image_shape</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.measure_brightness" href="#movemeter.tkgui.MovemeterTkGui.measure_brightness">measure_brightness</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.measure_movement" href="#movemeter.tkgui.MovemeterTkGui.measure_movement">measure_movement</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.new_group" href="#movemeter.tkgui.MovemeterTkGui.new_group">new_group</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.open_colormap_selection" href="#movemeter.tkgui.MovemeterTkGui.open_colormap_selection">open_colormap_selection</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.open_directory" href="#movemeter.tkgui.MovemeterTkGui.open_directory">open_directory</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.open_settings" href="#movemeter.tkgui.MovemeterTkGui.open_settings">open_settings</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.plot_results" href="#movemeter.tkgui.MovemeterTkGui.plot_results">plot_results</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.recalculate_old" href="#movemeter.tkgui.MovemeterTkGui.recalculate_old">recalculate_old</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.remove_directory" href="#movemeter.tkgui.MovemeterTkGui.remove_directory">remove_directory</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.replot_heatmap" href="#movemeter.tkgui.MovemeterTkGui.replot_heatmap">replot_heatmap</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.save_roiview" href="#movemeter.tkgui.MovemeterTkGui.save_roiview">save_roiview</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.set_fs" href="#movemeter.tkgui.MovemeterTkGui.set_fs">set_fs</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.set_roi" href="#movemeter.tkgui.MovemeterTkGui.set_roi">set_roi</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.set_settings" href="#movemeter.tkgui.MovemeterTkGui.set_settings">set_settings</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.set_status" href="#movemeter.tkgui.MovemeterTkGui.set_status">set_status</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.stop" href="#movemeter.tkgui.MovemeterTkGui.stop">stop</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.toggle_controls" href="#movemeter.tkgui.MovemeterTkGui.toggle_controls">toggle_controls</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.toggle_exclude" href="#movemeter.tkgui.MovemeterTkGui.toggle_exclude">toggle_exclude</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.undo" href="#movemeter.tkgui.MovemeterTkGui.undo">undo</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.update_grid" href="#movemeter.tkgui.MovemeterTkGui.update_grid">update_grid</a></code></li>
<li><code><a title="movemeter.tkgui.MovemeterTkGui.update_roitype_selection" href="#movemeter.tkgui.MovemeterTkGui.update_roitype_selection">update_roitype_selection</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
